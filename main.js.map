{"version":3,"sources":["webpack://todo/./src/view.js","webpack://todo/./src/index.js","webpack://todo/./src/mixins.js","webpack://todo/./src/model.js","webpack://todo/./src/controller.js"],"names":["tasksTargetElement","document","getElementById","tasksTargetButton","tasksTargetField","tasksViewObject","htmlElement","addButton","inputField","tasksViewMixin","itemName","renderOneItem","itemObject","itemID","id","p","createElement","deleteButton","innerHTML","dataset","itemid","classList","add","addEventListener","this","onClickDeleteItem","text","appendChild","initialize","onClickAddItem","setNewItemText","newItemText","value","renderExistingItems","viewModel","forEach","itemsViewMixin","tasksView","Object","assign","tasksModelMixin","data","addItem","itemText","newItemObject","creationCounter","push","deleteItem","itemObjectID","parseInt","indexItemToDelete","findIndex","currentItem","splice","tasksControllerMixin","itemsView","itemsModel","event","itemToDeleteID","target","itemsControllerMixin"],"mappings":"mBAIA,MCCMA,EAAqBC,SAASC,eAAe,SAC7CC,EAAoBF,SAASC,eAAe,YAC5CE,EAAmBH,SAASC,eAAe,cAM3CG,GAJqBJ,SAASC,eAAe,SACzBD,SAASC,eAAe,YACzBD,SAASC,eAAe,cDLtC,CACHI,YCMiCN,EDNpBO,UCMwCJ,EDN7BK,WCMgDJ,IAC1EK,ECdiB,SAAUC,GAe7B,SAASC,EAAcC,GACnB,MAAMC,EAASD,EAAWE,GACpBC,EAAId,SAASe,cAAc,KAC3BC,EAAehB,SAASe,cAAc,UAE5CC,EAAaC,UAAY,MACzBD,EAAaE,QAAQC,OAASP,EAC9BI,EAAaI,UAAUC,IAAI,sBAC3BL,EAAaM,iBAAiB,QAASC,KAAKC,mBAE5CV,EAAEG,UAAYN,EAAWc,KACzBX,EAAEY,YAAYV,GACdF,EAAEM,UAAUC,IAAI,QAEhBE,KAAKlB,YAAYqB,YAAYZ,GAEjC,MAAO,CACHa,WA5BJ,WACIJ,KAAKjB,UAAUgB,iBAAiB,QAASC,KAAKK,iBA2BlCC,eAzBhB,WACIN,KAAKO,YAAcP,KAAKhB,WAAWwB,OAwBPC,oBAtBhC,SAA6BC,GACzBV,KAAKhB,WAAWwB,MAAQ,GACxBR,KAAKlB,YAAYY,UAAY,GAC7BgB,EAAUC,QAAQxB,EAAea,OAmBgBK,eA/BhC,KA+BgDJ,kBA9B7C,MDYLW,GACjBC,EAAYC,OAAOC,OAAO,GAAIlC,EAAiBI,GAI/C+B,ECuDK,CAACC,KAnBsBA,EDtCd,GCyDFC,QAjBE,SAAUC,GAClB,MAAMC,EAAgB,CAClB9B,GAAMU,KAAKqB,gBACXnB,KAAMiB,GAEVF,EAAKK,KAAKF,GACVpB,KAAKqB,mBAWUE,WATJ,SAAUC,GACzBA,EAAeC,SAASD,GACxB,MAAME,EAAoBT,EAAKU,WAAU,SAASC,GAC9C,GAAIA,EAAYtC,KAAOkC,EACnB,OAAO,KAGfP,EAAKY,OAAOH,EAAmB,IAEAL,gBAlBb,GADF,IAAUJ,EDnClC,MAGMa,ECauB,SAAUC,EAAWC,GAC9C,SAAS3B,IACL0B,EAAUzB,iBACV0B,EAAWd,QAAQa,EAAUxB,aAC7BwB,EAAUtB,oBAAoBuB,EAAWf,MAE7C,SAAShB,EAAkBgC,GACvB,MAAMC,EAAiBD,EAAME,OAAOxC,QAAQC,OAC5CoC,EAAWT,WAAWW,GACtBH,EAAUtB,oBAAoBuB,EAAWf,MAO7C,MAAO,CAACb,WALR,WACI2B,EAAU1B,eAAiBA,EAC3B0B,EAAU9B,kBAAoBA,EAC9B8B,EAAU3B,eD3BWgC,CAAqBvB,EAH/BC,OAAOC,OAAO,GElBtB,GFkB4CC,IAI/BF,OAAOC,OAAO,GGtB3B,GHsBsDe,GACjD1B,c","file":"main.js","sourcesContent":["//editTask\n\n//moveTask (inside a taskList and to another taskList)\n\nconst tasksViewFactory = function (htmlElement, addButton, inputField) {\n    \n    return {\n        htmlElement, addButton, inputField\n    }\n}\n\nexport {tasksViewFactory}\n\n//Old initial constructor Code rewritten above into Factory function\n/*const TasksView = function (htmlElement, addButton, inputField) {\n    this.htmlElement = htmlElement;\n    this.addButton = addButton;\n    this.inputField = inputField;\n    this.newTaskText = null;\n    this.onClickAddTask = null;\n}\nTasksView.prototype.initialize = function () {\n    this.addButton.addEventListener('click', this.onClickAddTask);\n};\nTasksView.prototype.renderExistingTasks = function (viewModel) {\n    this.htmlElement.innerHTML = '';\n    viewModel.forEach(this.renderOneTask.bind(this));\n}\nTasksView.prototype.renderNewTask = function () {\n    this.newTaskText = this.inputField.value;\n    this.inputField.value = '';\n    this.renderOneTask(this.newTaskText);\n}\nTasksView.prototype.renderOneTask = function (task) {\n    const p = document.createElement(\"p\");  \n    p.innerHTML = task;\n    this.htmlElement.appendChild(p);\n}*/","import {tasksViewFactory} from './view';\nimport {tasksModelFactory} from './model';\nimport {tasksControllerFactory} from './controller';\nimport {itemsViewMixin, itemsControllerMixin, itemsModelMixin} from './mixins';\n\nconst tasksTargetElement = document.getElementById('tasks');\nconst tasksTargetButton = document.getElementById('task-add');\nconst tasksTargetField = document.getElementById('task-input');\n\nconst listsTargetElement = document.getElementById('lists');\nconst listsTargetButton = document.getElementById('list-add');\nconst listsTargetField = document.getElementById('list-input');\n\nconst tasksViewObject = tasksViewFactory(tasksTargetElement, tasksTargetButton, tasksTargetField);\nconst tasksViewMixin = itemsViewMixin ('task');\nconst tasksView = Object.assign({}, tasksViewObject, tasksViewMixin);\n\nconst initialData = [];\nconst tasksModelObject = tasksModelFactory();\nconst tasksModelMixin = itemsModelMixin (initialData);\nconst tasksModel = Object.assign({}, tasksModelObject, tasksModelMixin);\n\nconst tasksControllerObject = tasksControllerFactory();\nconst tasksControllerMixin = itemsControllerMixin(tasksView, tasksModel);\nconst tasksController = Object.assign({}, tasksControllerObject, tasksControllerMixin);\ntasksController.initialize();\n\n/*logic of todo app\n\n1. Describe in your own words what this app should look like and do\n\n    - Look and Feel:\n        Top      - task input field with add button\n            Later: search field\n        Mid      -tasks with delete button\n            Headline with current Listname and editButton/deleteButton\n        Right    - clicked task\n            TaskName editable\n            TaskNotes editable\n            Later: change to Project button\n        Left     - lists container\n            List input field with add button\n            Current list highlighted\n\n    - Start screen:\n        Defaults to Inbox list\n\n    - Do:\n\n        Create task after user entered one and pressed on add\n        Delete task after user clicked on delete of one task\n        Show task in Detail on the right side after user clicked on it\n            Make taskName editable after user clicked on it\n            Make taskNote editable after user clicked on it\n        Move task around when user clicks on it and holds click\n            Show visual help where task would go\n            Place task when user doesn't hold click anymore\n\n        Create list after user entered one and pressed on add\n        Make listName editable after user clicked on editButton\n            Rename listName after user pressed enter\n        Check after user clicked on deleteButton: tasks in this list?\n            If yes ask user if really delete it with all containing tasks\n                If yes delete list with all containing taks\n                If no forget about delete wish of user\n            If no delete list\n\n        Later: keep the deleted tasks of the last 3 days in a deletedlist\n        --> User can somehow undo deletion\n\n2. Algorithm: Plan how to realize your app - describe code in plain english\n\n- index.js for initializing and connecting everything\n        import functions from domStuff\n        import functions from todoController\n        call renderStartpage\n        create\n\n- Module for taskModel\n    attr: taskID\n    attr: taskName\n    attr: taskNote\n\n    func: setTaskID --> automatically when task is created\n    func: getTaskID\n    func: setTaskName\n    func: getTaskName\n    func: setTaskNote\n    func: getTaskNote\n    func: deleteTask\n\n    - Module for taskView, inject: htmlContainer\n    attr: onClickRenderDetails = null;\n\n    - Module for taskController\n\n\nPenguinView.prototype.render = function render(viewModel) {\n  this.element.innerHTML = '<h3>' + viewModel.name + '</h3>' +\n    '<img class=\"penguin-image\" src=\"' + viewModel.imageUrl +\n      '\" alt=\"' + viewModel.name + '\" />' +\n    '<p><b>Size:</b> ' + viewModel.size + '</p>' +\n    '<p><b>Favorite food:</b> ' + viewModel.favoriteFood + '</p>' +\n    '<a id=\"previousPenguin\" class=\"previous button\" href=\"javascript:void(0);\"' +\n      ' data-penguin-index=\"' + viewModel.previousIndex + '\">Previous</a> ' +\n    '<a id=\"nextPenguin\" class=\"next button\" href=\"javascript:void(0);\"' +\n      ' data-penguin-index=\"' + viewModel.nextIndex + '\">Next</a>';\n\n  ??this.previousIndex = viewModel.previousIndex;\n  ??this.nextIndex = viewModel.nextIndex;\n\n  var previousPenguin = this.element.querySelector('#previousPenguin');\n  previousPenguin.addEventListener('click', this.onClickGetPenguin);\n};\n\nvar TasksView = function TasksView(htmlElement) {\n    this.htmlElement = htmlElement;\n    this.onClickAddTask = null;\n}\n\nTasksView.prototype.render = function render(viewModel) {\n    this.htmlElement = viewModel.forEach(renderOneTask);\n\n    function renderOneTask(task) {\n        `<p> ${task}</p>`\n    }\n\n    var addTask = this.htmlElement.querySelector('#addTask');\n    addTask.addEventListener('click', this.onClickAddTask);\n}\n\nvar tasksTargetElement = document.getElementById('taskContainer');\n\nvar taskView = new TasksView(tasksTargetElement);\n\ntaskView.onClickAddTask\n\nvar testModel = ['dfdsfsdfsdf', '23432423432df'];\n\ntaskView.render(testModel);\n\n\n\n\n\n\n\n2. Algorithm: Plan how to realize your app - describe code in plain english\n\n    - index.js for initializing and connecting everything\n        import functions from domStuff\n        import functions from todoController\n        call renderStartpage\n        create\n\n    - Module for taskFactory\n        attr: taskID\n        attr: taskName\n        attr: taskNote\n\n        func: setTaskID --> automatically when task is created\n        func: getTaskID\n        func: setTaskName\n        func: getTaskName\n        func: setTaskNote\n        func: getTaskNote\n        func: deleteTask\n\n    - Module for listFactory\n        attr: lListID\n        attr: listName\n        attr: assignedTasks(array or object?)\n\n        func: addTask\n        func: removeTask\n        func: changeOrderAssigendTasks(task, new place)\n        func: setListID\n        func: getListID\n        func: setListName\n        func: getListName\n        func: deletelist\n\n    - Module for renderStartUI\n        attr: assignedTasksToList (to all created lists? Or only active one?)\n        func: renderStartPage\n                call renderListTabs\n                call renderActiveListTasks(inbox)\n                call highlightActiveListTab\n                call initListeners\n        func: renderListTabs\n        func: renderActiveListTasks(activeList)\n        func: highlightActiveListTab\n\n        func: initListeners\n            call addListenerToLists\n            call\n            call\n        func: listenToLists        --> call renderAsignedTasks\n                                   --> call highlightActiveListTab\n        func: listenToOneTask(cl)  --> call renderTaskDetails\n        func: listenToOneTaks(clh) --> call moveTask\n            to active task\n                taskName input field + enter --> changeTaskName\n                taskNote input field + enter --> changeTaskNote\n        func: listenToListDelete   --> call validateListDelete from TodoController\n        func: listenToListEdit     --> call validateListEdit from TodoController\n        func: listenToAllTasks     --> call listenToOneTask(cl)\n                                   --> call listenToOneTaks(clh)\n        func: listenToTaskDelete   --> call deleteTask(task) from todoController\n        func: renderTaskDetails(task)\n        func: addTasktoView --> display this task next to the already displayed tasks\n        func: deleteTaskfromView --> possible without rendering all other tasks?\n                                 --> delete task from assignedTaskstoList\n        func: moveTaskInList --> change assigned tasks order in temporarily generated array\n                                 render the tasks appropriately (rendering all new needed?)\n\n    - Module for todoController\n\n        func: addTask         --> create new task object with taskFactory\n                              --> call addTasktoView from domStuff\n                              --> put reference to created task into the right list\n                              (--> call storeTask from taskStorage)\n\n        func: deleteTask(task)--> delete task object\n                              --> call deleteTaskfromView from domStuff\n                              --> call deleteTask from right list\n                              (--> call deleteTask from taskStorage)\n\n        func: moveTask        --> if inside: call moveTaskinList from domStuff\n                                             call list.changeOrderAssignedTasks\n\n                              --> if outside: call newList.addTask\n                                              call oldList.deleteTask\n\n\n        func: addList         --> create new list object with listFactory\n        func: list.delete\n        func: validateListDelete\n        func: validateListEdit\n\n\n    - At the end: Module for taskStorage\n\n        attr: allTasks (also with reference to the list? Maybe for performance?)\n        func: deleteTask (later: put into attr deletedTask for 3 days)\n        func: storeTask\n        func: getAllTasks\n\n3. Divide your plan further and code\n\n    Kommt das ganze validation Zeugs als best practice in die setter der objects rein?\n    Von meinem Verständnis her ja --> Also validation methods oben entsprechend abändern/verschieben.\n\n    - Validate: is there a taskName or listName entered?\n\n    Falls ich assigendTasks mit object löse --> Reihenfolge fürs Rendern?\n    Wie die Reihe ist? Oder noch extra attribute wie z.B. Nummer/platz hinzufügen?\n\n*/","const itemsViewMixin = function (itemName) {\n    let onClickAddItem = null;\n    let onClickDeleteItem = null;\n\n    function initialize() {\n        this.addButton.addEventListener('click', this.onClickAddItem);\n    };\n    function setNewItemText () {\n        this.newItemText = this.inputField.value;\n    }\n    function renderExistingItems(viewModel) {\n        this.inputField.value = '';\n        this.htmlElement.innerHTML = '';\n        viewModel.forEach(renderOneItem, this);\n    };\n    function renderOneItem(itemObject) {\n        const itemID = itemObject.id;\n        const p = document.createElement('p');\n        const deleteButton = document.createElement('button')\n\n        deleteButton.innerHTML = 'del';\n        deleteButton.dataset.itemid = itemID;\n        deleteButton.classList.add(`delete-${itemName}-button`);\n        deleteButton.addEventListener('click', this.onClickDeleteItem);\n\n        p.innerHTML = itemObject.text;\n        p.appendChild(deleteButton);\n        p.classList.add(`${itemName}`);\n\n        this.htmlElement.appendChild(p);\n    };\n    return {\n        initialize, setNewItemText, renderExistingItems, onClickAddItem, onClickDeleteItem\n    }\n}\n\nconst itemsControllerMixin = function (itemsView, itemsModel) {\n    function onClickAddItem() {\n        itemsView.setNewItemText();\n        itemsModel.addItem(itemsView.newItemText);\n        itemsView.renderExistingItems(itemsModel.data);       \n    }\n    function onClickDeleteItem(event) {\n        const itemToDeleteID = event.target.dataset.itemid;\n        itemsModel.deleteItem(itemToDeleteID);\n        itemsView.renderExistingItems(itemsModel.data);\n    }\n    function initialize() {\n        itemsView.onClickAddItem = onClickAddItem;\n        itemsView.onClickDeleteItem = onClickDeleteItem;\n        itemsView.initialize();\n    }\n    return {initialize}\n}\n\nconst itemsModelMixin = function (data) {\n    let creationCounter = 0;\n    const addItem = function (itemText) {\n            const newItemObject = {\n                id :  this.creationCounter,\n                text: itemText\n            }\n            data.push(newItemObject);\n            this.creationCounter++;\n    }\n    const deleteItem = function (itemObjectID) {\n        itemObjectID = parseInt(itemObjectID);\n        const indexItemToDelete = data.findIndex(function(currentItem) {\n            if (currentItem.id === itemObjectID){\n                return true;\n            }\n        })\n        data.splice(indexItemToDelete, 1);\n    }\n    return {data, addItem, deleteItem, creationCounter}\n}\n\nexport {itemsViewMixin, itemsControllerMixin, itemsModelMixin}","const tasksModelFactory = function () {\n\n    return {}\n}\n\nexport {tasksModelFactory}\n\n//Old initial constructor code rewritten above into factory function\n/*const TasksModel = function (data) {\n    this.data = data;\n    this.addTask = function (newTask) {\n        this.data.push(newTask);\n    }\n}*/","const tasksControllerFactory = function () {\n\n    return {}\n}\n\nexport {tasksControllerFactory}\n\n//Old initial constructor code rewritten above into factory function\n/*const TasksController = function (tasksView, tasksModel) {\n    this.tasksView = tasksView;\n    this.tasksModel = tasksModel;\n}\n\nTasksController.prototype.onClickAddTask = function () {\n    console.log('in onClickAddTask');\n    this.tasksView.renderExistingTasks(this.tasksModel.data);\n    this.tasksView.renderNewTask();\n    this.tasksModel.addTask(this.tasksView.newTaskText);\n}\n\nTasksController.prototype.initialize = function () {\n    this.tasksView.onClickAddTask = this.onClickAddTask.bind(this);\n    this.tasksView.initialize();\n};*/"],"sourceRoot":""}